#include "../../src/alloc.h"
#include "../../src/constants.h"
#include "../../src/shared/log.h"
#include "../../src/exit_codes.h"
#include "../../src/protocol_v2/solver/v2_registry.h"
#include "../../src/elm_json.h"
#include "../../src/commands/package/package_common.h"
#include "../../src/cache.h"
#include "../../src/vendor/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <libgen.h>
#include <errno.h>
#include <unistd.h>

/* Implementation of version_parse_safe from package_common.c to avoid linking the whole file */
bool version_parse_safe(const char *version_str, Version *out) {
    if (!version_str || !out) {
        return false;
    }

    int major = 0;
    int minor = 0;
    int patch = 0;

    if (sscanf(version_str, "%d.%d.%d", &major, &minor, &patch) != 3) {
        return false;
    }

    if (major < 0 || minor < 0 || patch < 0) {
        return false;
    }

    out->major = (uint16_t)major;
    out->minor = (uint16_t)minor;
    out->patch = (uint16_t)patch;
    return true;
}

/* Implementation of parse_package_name from package_common.c */
bool parse_package_name(const char *package, char **author, char **name) {
    if (!package) return false;

    const char *slash = strchr(package, '/');
    if (!slash) {
        fprintf(stderr, "Error: Package name must be in format 'author/package'\n");
        return false;
    }

    size_t author_len = slash - package;
    *author = arena_malloc(author_len + 1);
    if (!*author) return false;
    strncpy(*author, package, author_len);
    (*author)[author_len] = '\0';

    *name = arena_strdup(slash + 1);
    if (!*name) {
        arena_free(*author);
        return false;
    }

    return true;
}

/* Helper to create directories recursively */
static bool ensure_directory(const char *path) {
    if (!path || path[0] == '\0') {
        return false;
    }

    struct stat st;
    if (stat(path, &st) == 0) {
        if (S_ISDIR(st.st_mode)) {
            return true; /* Directory already exists */
        }
        errno = EEXIST;
        return false; /* Exists but is not a directory */
    }

    /* Create parent directory first */
    char *path_copy = arena_strdup(path);
    if (!path_copy) {
        return false;
    }

    char *parent = dirname(path_copy);
    /* Make a copy of parent since dirname modifies the string in place */
    char *parent_copy = arena_strdup(parent);
    arena_free(path_copy);
    
    if (!parent_copy) {
        return false;
    }

    if (strcmp(parent_copy, ".") != 0 && strcmp(parent_copy, "/") != 0 && strcmp(parent_copy, path) != 0) {
        if (!ensure_directory(parent_copy)) {
            arena_free(parent_copy);
            return false;
        }
    }
    arena_free(parent_copy);

    /* Create this directory */
    if (mkdir(path, DIR_PERMISSIONS) != 0 && errno != EEXIST) {
        return false;
    }

    return true;
}

static bool write_package_elm_json(ElmJson *elm_json, const char *filepath) {
    FILE *f = fopen(filepath, "w");
    if (!f) {
        return false;
    }

    /* Write with 4-space indentation matching Elm's format */
    fprintf(f, "{\n");
    fprintf(f, "    \"type\": \"package\",\n");
    fprintf(f, "    \"name\": \"%s\",\n", elm_json->package_name);
    fprintf(f, "    \"summary\": \"generated by mkpkg\",\n");
    fprintf(f, "    \"license\": \"BSD-3-Clause\",\n");
    fprintf(f, "    \"version\": \"%s\",\n", elm_json->package_version);
    fprintf(f, "    \"exposed-modules\": [],\n");
    fprintf(f, "    \"elm-version\": \"%s\",\n", elm_json->elm_version);
    
    /* Write dependencies */
    fprintf(f, "    \"dependencies\": {");
    if (elm_json->package_dependencies && elm_json->package_dependencies->count > 0) {
        fprintf(f, "\n");
        for (int i = 0; i < elm_json->package_dependencies->count; i++) {
            Package *pkg = &elm_json->package_dependencies->packages[i];
            fprintf(f, "        \"%s/%s\": \"%s\"", pkg->author, pkg->name, pkg->version);
            if (i < elm_json->package_dependencies->count - 1) {
                fprintf(f, ",");
            }
            fprintf(f, "\n");
        }
        fprintf(f, "    },\n");
    } else {
        fprintf(f, "},\n");
    }
    
    /* Write test-dependencies */
    fprintf(f, "    \"test-dependencies\": {");
    if (elm_json->package_test_dependencies && elm_json->package_test_dependencies->count > 0) {
        fprintf(f, "\n");
        for (int i = 0; i < elm_json->package_test_dependencies->count; i++) {
            Package *pkg = &elm_json->package_test_dependencies->packages[i];
            fprintf(f, "        \"%s/%s\": \"%s\"", pkg->author, pkg->name, pkg->version);
            if (i < elm_json->package_test_dependencies->count - 1) {
                fprintf(f, ",");
            }
            fprintf(f, "\n");
        }
        fprintf(f, "    }\n");
    } else {
        fprintf(f, "}\n");
    }
    
    fprintf(f, "}");
    fclose(f);
    return true;
}

static void print_usage(const char *prog) {
    fprintf(stderr, "Usage: %s REGISTRY PACKAGE\n", prog);
    fprintf(stderr, "  REGISTRY: Path to V2 registry file\n");
    fprintf(stderr, "  PACKAGE: Package name (author/name)\n");
    fprintf(stderr, "  Optional: Set ELM_HOME environment variable (defaults to ~/.elm/VERSION).\n");
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        print_usage(argv[0]);
        return EXIT_GENERAL_ERROR;
    }

    const char *registry_path = argv[1];
    const char *package_spec = argv[2];

    /* Initialize cache configuration to get proper paths */
    CacheConfig *cache = cache_config_init();
    if (!cache) {
        fprintf(stderr, "Error: Failed to initialize cache configuration.\n");
        return EXIT_GENERAL_ERROR;
    }

    /* Parse package spec */
    char *spec_copy = arena_strdup(package_spec);
    char *slash = strchr(spec_copy, '/');
    if (!slash) {
        fprintf(stderr, "Error: Invalid package specification '%s'. Expected 'author/name'.\n", package_spec);
        return EXIT_GENERAL_ERROR;
    }
    *slash = '\0';
    const char *author = spec_copy;
    const char *name = slash + 1;

    /* Load registry */
    V2Registry *registry = v2_registry_load_from_text(registry_path);
    if (!registry) {
        fprintf(stderr, "Error: Failed to load registry from '%s'.\n", registry_path);
        cache_config_free(cache);
        return EXIT_GENERAL_ERROR;
    }

    /* Find all entries for this package (registry file may have multiple package: blocks for same package) */
    size_t total_versions = 0;
    for (size_t i = 0; i < registry->entry_count; i++) {
        if (strcmp(registry->entries[i].author, author) == 0 &&
            strcmp(registry->entries[i].name, name) == 0) {
            total_versions += registry->entries[i].version_count;
        }
    }

    if (total_versions == 0) {
        fprintf(stderr, "Error: Package '%s/%s' not found in registry.\n", author, name);
        cache_config_free(cache);
        return EXIT_GENERAL_ERROR;
    }

    printf("Found package %s/%s with %zu total versions.\n", author, name, total_versions);

    /* Process each version from all matching entries */
    for (size_t i = 0; i < registry->entry_count; i++) {
        if (strcmp(registry->entries[i].author, author) != 0 ||
            strcmp(registry->entries[i].name, name) != 0) {
            continue;
        }

        V2PackageEntry *entry = &registry->entries[i];
        for (size_t j = 0; j < entry->version_count; j++) {
            V2PackageVersion *ver = &entry->versions[j];
            
            /* Construct version string */
            char version_str[MAX_VERSION_STRING_LENGTH];
            snprintf(version_str, sizeof(version_str), "%u.%u.%u", ver->major, ver->minor, ver->patch);

            /* Use cache_get_package_path for proper path: $ELM_HOME/version/packages/author/name/version */
            char *dir_path = cache_get_package_path(cache, author, name, version_str);
            if (!dir_path) {
                fprintf(stderr, "Error: Failed to construct package path for %s/%s %s.\n", author, name, version_str);
                continue;
            }

            printf("Creating %s...\n", dir_path);

            if (!ensure_directory(dir_path)) {
                fprintf(stderr, "Error: Failed to create directory '%s'.\n", dir_path);
                arena_free(dir_path);
                continue;
            }

            /* Create src directory */
            size_t src_path_len = strlen(dir_path) + strlen("/src") + 1;
            char *src_path = arena_malloc(src_path_len);
            if (!src_path) {
                fprintf(stderr, "Error: Failed to allocate memory for src path.\n");
                arena_free(dir_path);
                continue;
            }
            snprintf(src_path, src_path_len, "%s/src", dir_path);
            if (!ensure_directory(src_path)) {
                fprintf(stderr, "Error: Failed to create directory '%s'.\n", src_path);
                arena_free(src_path);
                arena_free(dir_path);
                continue;
            }

            /* Create elm.json */
            ElmJson *elm_json = arena_calloc(1, sizeof(ElmJson));
            elm_json->type = ELM_PROJECT_PACKAGE;
            
            /* Convert compiler version to a range constraint (e.g., "0.19.1" -> "0.19.0 <= v < 0.20.0") */
            const char *compiler_ver = registry->compiler_version ? registry->compiler_version : "0.19.1";
            char elm_version_range[MAX_RANGE_STRING_LENGTH];
            int major = 0, minor = 0, patch = 0;
            if (sscanf(compiler_ver, "%d.%d.%d", &major, &minor, &patch) == 3) {
                snprintf(elm_version_range, sizeof(elm_version_range), "%d.%d.0 <= v < %d.%d.0", 
                         major, minor, major, minor + 1);
            } else {
                /* Fallback if parsing fails */
                snprintf(elm_version_range, sizeof(elm_version_range), "0.19.0 <= v < 0.20.0");
            }
            elm_json->elm_version = arena_strdup(elm_version_range);
            
            elm_json->package_name = arena_strdup(package_spec);
            elm_json->package_version = arena_strdup(version_str);
            elm_json->package_dependencies = package_map_create();
            elm_json->package_test_dependencies = package_map_create();

            /* Add dependencies */
            for (size_t k = 0; k < ver->dependency_count; k++) {
                V2Dependency *dep = &ver->dependencies[k];
                
                /* Parse dependency name */
                char *dep_name_copy = arena_strdup(dep->package_name);
                char *dep_slash = strchr(dep_name_copy, '/');
                if (dep_slash) {
                    *dep_slash = '\0';
                    const char *dep_author = dep_name_copy;
                    const char *dep_pkg_name = dep_slash + 1;
                    
                    /* We store the constraint as the version in the package map for elm.json */
                    package_map_add(elm_json->package_dependencies, dep_author, dep_pkg_name, dep->constraint);
                }
            }

            size_t elm_json_path_len = strlen(dir_path) + strlen("/elm.json") + 1;
            char *elm_json_path = arena_malloc(elm_json_path_len);
            if (!elm_json_path) {
                fprintf(stderr, "Error: Failed to allocate memory for elm.json path.\n");
                arena_free(src_path);
                arena_free(dir_path);
                continue;
            }
            snprintf(elm_json_path, elm_json_path_len, "%s/elm.json", dir_path);
            
            if (!write_package_elm_json(elm_json, elm_json_path)) {
                fprintf(stderr, "Error: Failed to write elm.json to '%s'.\n", elm_json_path);
            }

            /* Cleanup paths for this version */
            arena_free(elm_json_path);
            arena_free(src_path);
            arena_free(dir_path);
        }
    }

    /* Cleanup */
    cache_config_free(cache);

    return EXIT_SUCCESS;
}
