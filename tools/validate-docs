#!/usr/bin/env bash

set -euo pipefail

# Get script directory and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
ELM_WRAP_BIN="$PROJECT_ROOT/bin/elm-wrap"

# Logging function
log() {
    echo "$@"
}

log_err() {
    echo "$@" >&2
}

# Usage message
usage() {
    log "Usage: $(basename "$0") <repository-path> <target-path>"
    log ""
    log "Generates docs for all packages in <repository-path> and compares them"
    log "against original docs.json files collected in <target-path>."
    exit 1
}

# Check arguments
if [ $# -ne 2 ]; then
    usage
fi

REPOSITORY_DIR="$1"
TARGET_DIR="$2"

# Check if repository directory exists
if [ ! -d "$REPOSITORY_DIR" ]; then
    log_err "Error: Repository directory not found at $REPOSITORY_DIR"
    exit 1
fi

# Check if target directory exists
if [ ! -d "$TARGET_DIR" ]; then
    log_err "Error: Target directory not found at $TARGET_DIR"
    exit 1
fi

# Check if elm-wrap binary exists
if [ ! -x "$ELM_WRAP_BIN" ]; then
    log_err "Error: elm-wrap binary not found at $ELM_WRAP_BIN"
    exit 1
fi

# Convert to absolute paths
REPOSITORY_DIR="$(cd "$REPOSITORY_DIR" && pwd)"
TARGET_DIR="$(cd "$TARGET_DIR" && pwd)"

# Initialize counters
GENERATED_COUNT=0
GENERATE_FAIL_COUNT=0

log "Validating documentation"
log "Repository: $REPOSITORY_DIR"
log "Target: $TARGET_DIR"
log ""

# Record start time
START_TIME=$(date +%s)

# Phase 1: Generate docs for all packages
log "Phase 1: Generating documentation..."

process_package() {
    local package_dir="$1"
    local elm_json_path="$package_dir/elm.json"
    
    # Check if elm.json exists
    if [ ! -f "$elm_json_path" ]; then
        return
    fi
    
    # Check if docs.json exists - skip silently if not
    local docs_json_path="$package_dir/docs.json"
    if [ ! -f "$docs_json_path" ]; then
        return
    fi

    # Check if src directory exists - skip silently if not
    local src_dir="$package_dir/src"
    if [ ! -d "$src_dir" ]; then
        return
    fi

    # Calculate relative path from repository directory and convert to flat filename
    local relative_path="${package_dir#$REPOSITORY_DIR}"
    relative_path="${relative_path#/}"  # Remove leading slash if present
    
    # Replace path separators with underscores to create flat filename
    local flat_name="${relative_path//\//_}"
    local output_file="$TARGET_DIR/${flat_name}_docs.generated.json"

    # Generate docs using elm-wrap (capture output and errors separately)
    local tmpdir
    tmpdir=$(mktemp -d)
    local raw_output="$tmpdir/raw.json"
    local elm_wrap_stderr="$tmpdir/elm-wrap.stderr"
    local jq_stderr="$tmpdir/jq.stderr"
    
    # Run elm-wrap and capture exit status
    local elm_wrap_status=0
    "$ELM_WRAP_BIN" publish docs "$package_dir" > "$raw_output" 2> "$elm_wrap_stderr" || elm_wrap_status=$?
    
    if [ $elm_wrap_status -ne 0 ]; then
        log_err "[generate-failed] $relative_path"
        log_err "  elm-wrap exit status: $elm_wrap_status"
        if [ -s "$elm_wrap_stderr" ]; then
            log_err "  elm-wrap stderr: $(cat "$elm_wrap_stderr")"
        fi
        GENERATE_FAIL_COUNT=$((GENERATE_FAIL_COUNT + 1))
        rm -rf "$tmpdir"
        return
    fi
    
    # Run jq to format the output
    local jq_status=0
    jq . "$raw_output" > "$output_file" 2> "$jq_stderr" || jq_status=$?
    
    if [ $jq_status -ne 0 ]; then
        log_err "[generate-failed] $relative_path"
        log_err "  jq exit status: $jq_status"
        if [ -s "$jq_stderr" ]; then
            log_err "  jq stderr: $(cat "$jq_stderr")"
        fi
        GENERATE_FAIL_COUNT=$((GENERATE_FAIL_COUNT + 1))
        rm -f "$output_file"
        rm -rf "$tmpdir"
        return
    fi
    
    GENERATED_COUNT=$((GENERATED_COUNT + 1))
    rm -rf "$tmpdir"
}

# Find all elm.json files and process their directories
while IFS= read -r -d '' elm_json_path; do
    package_dir="$(dirname "$elm_json_path")"
    process_package "$package_dir"
done < <(find "$REPOSITORY_DIR" -name "elm.json" -type f -print0 | sort -z)

GENERATE_END_TIME=$(date +%s)
GENERATE_DURATION=$((GENERATE_END_TIME - START_TIME))

log ""
log "Phase 1 complete: Generated $GENERATED_COUNT docs in ${GENERATE_DURATION}s (${GENERATE_FAIL_COUNT} failures)"
log ""

# Phase 2: Compare generated docs with originals
log "Phase 2: Comparing documentation..."

SUCCESS_COUNT=0
FAIL_COUNT=0
MISSING_ORIGINAL=0

# Find all generated docs and compare with originals
for generated_file in "$TARGET_DIR"/*_docs.generated.json; do
    [ -f "$generated_file" ] || continue
    
    # Extract the base name (without _docs.generated.json)
    base_name="$(basename "$generated_file" _docs.generated.json)"
    original_file="$TARGET_DIR/${base_name}_docs.json"
    
    # Check if original exists
    if [ ! -f "$original_file" ]; then
        MISSING_ORIGINAL=$((MISSING_ORIGINAL + 1))
        continue
    fi
    
    # Convert flat name back to author/package/version format
    # The flat name is like: author_package_version
    # We need to convert underscores back to slashes
    package_path="${base_name//_//}"
    
    # Compare the files
    if diff -q "$original_file" "$generated_file" > /dev/null 2>&1; then
        SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
    else
        log_err "[different] $package_path"
        FAIL_COUNT=$((FAIL_COUNT + 1))
    fi
done

END_TIME=$(date +%s)
TOTAL_DURATION=$((END_TIME - START_TIME))
TOTAL_COMPARED=$((SUCCESS_COUNT + FAIL_COUNT))

log ""
log "Phase 2 complete."
log ""
log "=== Summary ==="
log "Total packages processed: $GENERATED_COUNT"
log "Total packages compared: $TOTAL_COMPARED"
log "Successes: $SUCCESS_COUNT"
log "Failures: $FAIL_COUNT"
if [ $MISSING_ORIGINAL -gt 0 ]; then
    log "Missing originals: $MISSING_ORIGINAL"
fi
log "Total time: ${TOTAL_DURATION}s"
