#!/usr/bin/env bash

set -euo pipefail

# Get script directory and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
ELM_WRAP_BIN="$PROJECT_ROOT/bin/elm-wrap"

# Default paths
DEFAULT_REPOSITORY_DIR="/Volumes/Devel/var/elm-wrap/package_repository/0.19.1/packages/"
DEFAULT_TARGET_DIR="$PROJECT_ROOT/tmp/docs"

# Logging function
log() {
    echo "$@"
}

log_err() {
    echo "$@" >&2
}

# Usage message
usage() {
    log "Usage: $(basename "$0") [<repository-path> <target-path>]"
    log "       $(basename "$0") <author/package/version>"
    log ""
    log "Generates docs for packages in <repository-path> and compares them"
    log "against original docs.json files collected in <target-path>."
    log ""
    log "If a single argument is provided, validates only that package using default paths."
    log ""
    log "Default repository: $DEFAULT_REPOSITORY_DIR"
    log "Default target: tmp/docs"
    exit 1
}

# Parse arguments
SINGLE_PACKAGE=""
if [ $# -eq 0 ]; then
    REPOSITORY_DIR="$DEFAULT_REPOSITORY_DIR"
    TARGET_DIR="$DEFAULT_TARGET_DIR"
elif [ $# -eq 1 ]; then
    REPOSITORY_DIR="$DEFAULT_REPOSITORY_DIR"
    TARGET_DIR="$DEFAULT_TARGET_DIR"
    SINGLE_PACKAGE="$1"
elif [ $# -eq 2 ]; then
    REPOSITORY_DIR="$1"
    TARGET_DIR="$2"
else
    usage
fi

# Check if repository directory exists
if [ ! -d "$REPOSITORY_DIR" ]; then
    log_err "Error: Repository directory not found at $REPOSITORY_DIR"
    exit 1
fi

# Check if target directory exists
if [ ! -d "$TARGET_DIR" ]; then
    log_err "Error: Target directory not found at $TARGET_DIR"
    exit 1
fi

# Check if elm-wrap binary exists
if [ ! -x "$ELM_WRAP_BIN" ]; then
    log_err "Error: elm-wrap binary not found at $ELM_WRAP_BIN"
    exit 1
fi

# Convert to absolute paths
REPOSITORY_DIR="$(cd "$REPOSITORY_DIR" && pwd)"
TARGET_DIR="$(cd "$TARGET_DIR" && pwd)"

# Initialize counters
GENERATED_COUNT=0
GENERATE_FAIL_COUNT=0

log "Validating documentation"
log "Repository: $REPOSITORY_DIR"
log "Target: $TARGET_DIR"
log ""

# Record start time
START_TIME=$(date +%s)

# Phase 1: Generate docs for all packages
log "Phase 1: Generating documentation..."

process_package() {
    local package_dir="$1"
    local elm_json_path="$package_dir/elm.json"
    
    # Check if elm.json exists
    if [ ! -f "$elm_json_path" ]; then
        return
    fi
    
    # Check if docs.json exists - skip silently if not
    local docs_json_path="$package_dir/docs.json"
    if [ ! -f "$docs_json_path" ]; then
        return
    fi

    # Check if src directory exists - skip silently if not
    local src_dir="$package_dir/src"
    if [ ! -d "$src_dir" ]; then
        return
    fi

    # Calculate relative path from repository directory and convert to flat filename
    local relative_path="${package_dir#"$REPOSITORY_DIR"}"
    relative_path="${relative_path#/}"  # Remove leading slash if present
    
    # Replace path separators with underscores to create flat filename
    local flat_name="${relative_path//\//_}"
    local output_file="$TARGET_DIR/${flat_name}_docs.generated.json"

    # Generate docs using elm-wrap (capture output and errors separately)
    local tmpdir
    tmpdir=$(mktemp -d)
    local raw_output="$tmpdir/raw.json"
    local elm_wrap_stderr="$tmpdir/elm-wrap.stderr"
    local jq_stderr="$tmpdir/jq.stderr"
    
    # Run elm-wrap and capture exit status
    local elm_wrap_status=0
    "$ELM_WRAP_BIN" publish docs "$package_dir" > "$raw_output" 2> "$elm_wrap_stderr" || elm_wrap_status=$?
    
    if [ $elm_wrap_status -ne 0 ]; then
        log_err "[generate-failed] $relative_path"
        log_err "  elm-wrap exit status: $elm_wrap_status"
        if [ -s "$elm_wrap_stderr" ]; then
            log_err "  elm-wrap stderr: $(cat "$elm_wrap_stderr")"
        fi
        GENERATE_FAIL_COUNT=$((GENERATE_FAIL_COUNT + 1))
        rm -rf "$tmpdir"
        return
    fi
    
    # Run jq to format the output
    local jq_status=0
    jq . "$raw_output" > "$output_file" 2> "$jq_stderr" || jq_status=$?
    
    if [ $jq_status -ne 0 ]; then
        log_err "[generate-failed] $relative_path"
        log_err "  jq exit status: $jq_status"
        if [ -s "$jq_stderr" ]; then
            log_err "  jq stderr: $(cat "$jq_stderr")"
        fi
        GENERATE_FAIL_COUNT=$((GENERATE_FAIL_COUNT + 1))
        rm -f "$output_file"
        rm -rf "$tmpdir"
        return
    fi
    
    GENERATED_COUNT=$((GENERATED_COUNT + 1))
    rm -rf "$tmpdir"
}

# Phase 1: Generate docs
if [ -n "$SINGLE_PACKAGE" ]; then
    # Single package mode
    package_dir="$REPOSITORY_DIR/$SINGLE_PACKAGE"
    if [ ! -d "$package_dir" ]; then
        log_err "Error: Package directory not found at $package_dir"
        exit 1
    fi
    process_package "$package_dir"
else
    # All packages mode
    while IFS= read -r -d '' elm_json_path; do
        package_dir="$(dirname "$elm_json_path")"
        process_package "$package_dir"
    done < <(find "$REPOSITORY_DIR" -name "elm.json" -type f -print0 | sort -z)
fi

GENERATE_END_TIME=$(date +%s)
GENERATE_DURATION=$((GENERATE_END_TIME - START_TIME))

log ""
log "Phase 1 complete: Generated $GENERATED_COUNT docs in ${GENERATE_DURATION}s (${GENERATE_FAIL_COUNT} failures)"
log ""

# Phase 2: Compare generated docs with originals
log "Phase 2: Comparing documentation..."

SUCCESS_COUNT=0
FAIL_COUNT=0
MISSING_ORIGINAL=0

# Compare docs
if [ -n "$SINGLE_PACKAGE" ]; then
    # Single package mode - compare just the one file
    flat_name="${SINGLE_PACKAGE//\//_}"
    generated_file="$TARGET_DIR/${flat_name}_docs.generated.json"
    original_file="$TARGET_DIR/${flat_name}_docs.json"
    
    if [ ! -f "$generated_file" ]; then
        log_err "Generated docs not found: $generated_file"
        "$SCRIPT_DIR/view-diff" "$REPOSITORY_DIR" "$TARGET_DIR" "$SINGLE_PACKAGE"
        exit 100
    elif [ ! -f "$original_file" ]; then
        log_err "Original docs not found: $original_file"
        "$SCRIPT_DIR/view-diff" "$REPOSITORY_DIR" "$TARGET_DIR" "$SINGLE_PACKAGE"
        exit 100
    else
        if diff -q "$original_file" "$generated_file" > /dev/null 2>&1; then
            log "SUCCESS: $SINGLE_PACKAGE"
            exit 0
        else
            log_err "[different] $SINGLE_PACKAGE"
            "$SCRIPT_DIR/view-diff" "$REPOSITORY_DIR" "$TARGET_DIR" "$SINGLE_PACKAGE"
            exit 100
        fi
    fi
else
    # All packages mode - find all generated docs and compare with originals
    for generated_file in "$TARGET_DIR"/*_docs.generated.json; do
        [ -f "$generated_file" ] || continue
        
        # Extract the base name (without _docs.generated.json)
        base_name="$(basename "$generated_file" _docs.generated.json)"
        original_file="$TARGET_DIR/${base_name}_docs.json"
        
        # Check if original exists
        if [ ! -f "$original_file" ]; then
            MISSING_ORIGINAL=$((MISSING_ORIGINAL + 1))
            continue
        fi
    
        # Convert flat name back to author/package/version format
        # The flat name is like: author_package_version
        # We need to convert underscores back to slashes
        package_path="${base_name//_//}"
        
        # Compare the files
        if diff -q "$original_file" "$generated_file" > /dev/null 2>&1; then
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
        else
            log_err "[different] $package_path"
            FAIL_COUNT=$((FAIL_COUNT + 1))
        fi
    done
fi

END_TIME=$(date +%s)
TOTAL_DURATION=$((END_TIME - START_TIME))
TOTAL_COMPARED=$((SUCCESS_COUNT + FAIL_COUNT))

log ""
log "Phase 2 complete."
log ""
log "=== Summary ==="
log "Total packages processed: $GENERATED_COUNT"
log "Total packages compared: $TOTAL_COMPARED"
log "Successes: $SUCCESS_COUNT"
log "Failures: $FAIL_COUNT"
if [ $MISSING_ORIGINAL -gt 0 ]; then
    log "Missing originals: $MISSING_ORIGINAL"
fi
log "Total time: ${TOTAL_DURATION}s"
